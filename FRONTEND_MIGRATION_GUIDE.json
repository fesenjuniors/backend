{
  "migration_summary": {
    "title": "Backend API Changes: Players Map Removed - Use Sub-collections",
    "version": "2.0.0",
    "date": "2025-01-27",
    "description": "Complete refactoring to remove players Map from Match interface and use Firebase sub-collections instead",
    "breaking_changes": true
  },
  "key_changes": {
    "match_interface": {
      "before": "Match interface had players: Map<string, Player>",
      "after": "Match interface no longer has players property",
      "impact": "All frontend code accessing match.players will break"
    },
    "data_source": {
      "before": "Player data stored in in-memory Map",
      "after": "Player data stored in Firebase sub-collections",
      "impact": "All player operations now require API calls"
    }
  },
  "api_endpoint_changes": {
    "match_details": {
      "endpoint": "GET /api/match/:matchId",
      "changes": [
        "Now returns players array from sub-collection",
        "Response structure unchanged",
        "Added error handling for sub-collection failures"
      ],
      "before_example": "match.players.size",
      "after_example": "Use totalPlayers from API response"
    },
    "match_players": {
      "endpoint": "GET /api/match/:matchId/players",
      "changes": [
        "Now fetches players from sub-collection",
        "Response structure unchanged",
        "Added error handling"
      ]
    },
    "create_match": {
      "endpoint": "POST /api/match/create",
      "changes": [
        "Now async operation",
        "Admin name fetched from sub-collection",
        "Response structure unchanged"
      ]
    },
    "join_match": {
      "endpoint": "POST /api/match/:matchId/join",
      "changes": [
        "Player lookup now uses sub-collection",
        "Rejoin functionality improved",
        "Response structure unchanged"
      ]
    },
    "leaderboard": {
      "endpoint": "GET /api/match/:matchId/leaderboard",
      "changes": [
        "Now async operation",
        "Fetches from sub-collection",
        "Response structure unchanged"
      ]
    }
  },
  "websocket_changes": {
    "match_state_payload": {
      "before": {
        "type": "MatchStatePayload",
        "structure": {
          "matchId": "string",
          "state": "MatchState",
          "players": [
            {
              "id": "string",
              "name": "string",
              "score": "number",
              "state": "PlayerState"
            }
          ]
        }
      },
      "after": {
        "type": "MatchStatePayload",
        "structure": {
          "matchId": "string",
          "state": "MatchState"
        },
        "note": "Players array removed - use separate player events"
      }
    },
    "player_events": {
      "new_events": [
        "player:joined - when player joins match",
        "player:left - when player leaves match",
        "player:data - player's current data (inventory, scores)",
        "leaderboard:update - updated leaderboard"
      ],
      "removed_from_match_state": "Players array no longer included in match state events"
    }
  },
  "frontend_migration_required": {
    "broken_patterns": [
      "match.players.size",
      "match.players.get(playerId)",
      "match.players.values()",
      "match.players.keys()",
      "Array.from(match.players.values())",
      "match.players.has(playerId)",
      "match.players.set(playerId, player)",
      "match.players.delete(playerId)"
    ],
    "replacement_patterns": {
      "get_player_count": {
        "before": "match.players.size",
        "after": "Use totalPlayers from API response or listen to player:joined/player:left events"
      },
      "get_player": {
        "before": "match.players.get(playerId)",
        "after": "GET /api/match/:matchId/players or listen to player:data events"
      },
      "get_all_players": {
        "before": "Array.from(match.players.values())",
        "after": "GET /api/match/:matchId/players"
      },
      "check_player_exists": {
        "before": "match.players.has(playerId)",
        "after": "Check API response or maintain local state from events"
      }
    }
  },
  "recommended_frontend_changes": {
    "state_management": {
      "approach": "Maintain local players state from API responses and WebSocket events",
      "initialization": "Fetch players on match load: GET /api/match/:matchId/players",
      "updates": "Listen to WebSocket events for real-time updates"
    },
    "websocket_listeners": {
      "required_events": [
        "player:joined - add player to local state",
        "player:left - remove player from local state",
        "player:data - update player data in local state",
        "leaderboard:update - update leaderboard display",
        "match:state - update match state only (no players array)"
      ]
    },
    "api_calls": {
      "on_match_load": "GET /api/match/:matchId/players",
      "for_player_data": "GET /api/match/:matchId/players",
      "for_leaderboard": "GET /api/match/:matchId/leaderboard"
    }
  },
  "example_migration": {
    "before": {
      "code": "const playerCount = match.players.size;\nconst player = match.players.get(playerId);\nconst allPlayers = Array.from(match.players.values());"
    },
    "after": {
      "code": "// Option 1: Use API response\nconst response = await fetch(`/api/match/${matchId}/players`);\nconst { players, totalPlayers } = await response.json();\nconst playerCount = totalPlayers;\nconst player = players.find(p => p.id === playerId);\nconst allPlayers = players;\n\n// Option 2: Use local state from WebSocket events\nconst playerCount = localPlayersState.length;\nconst player = localPlayersState.find(p => p.id === playerId);\nconst allPlayers = localPlayersState;"
    }
  },
  "testing_changes": {
    "test_files_updated": [
      "tests/test-persistent-matches.ts - Updated to use new async methods",
      "All test files using match.players need similar updates"
    ],
    "new_test_patterns": "Use await matchManager.getPlayer() and await matchManager.getPlayers()"
  },
  "backward_compatibility": {
    "api_responses": "All API response structures remain the same",
    "websocket_events": "New events added, existing events maintained",
    "breaking_changes": "Frontend code accessing match.players will break"
  },
  "migration_checklist": [
    "Remove all match.players references",
    "Replace with API calls or local state management",
    "Add WebSocket listeners for player events",
    "Update player count logic to use totalPlayers from API",
    "Test player join/leave functionality",
    "Test leaderboard updates",
    "Test player data persistence"
  ],
  "support": {
    "documentation": "All API endpoints maintain same response structure",
    "websocket_events": "New player-specific events provide real-time updates",
    "error_handling": "All endpoints now include proper error handling for sub-collection failures"
  }
}
